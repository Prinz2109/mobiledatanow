<library>
	<class name="controller" >
		
		<method name="listVisibility" args="visibleList">
			<![CDATA[
			if (qb_grouping_list != visibleList && qb_grouping_list.visible){
				qb_grouping_list.setAttribute("visible", false);
			} 
			if (qb_actions_list != visibleList && qb_actions_list.visible){
				qb_actions_list.setAttribute("visible", false);
			} 
			if (qb_views_list != visibleList && qb_views_list.visible){
				qb_views_list.setAttribute("visible", false);
			}
			if (qb_subviews_list != visibleList && qb_subviews_list.visible){
				qb_subviews_list.setAttribute("visible", false);
			}
			if (qb_comp_list != visibleList && qb_comp_list.visible){
				qb_comp_list.setAttribute("visible", false);
			}
			if (qb_value_list != visibleList && qb_value_list.visible){
				qb_value_list.setAttribute("visible", false);
			}
			]]>
		</method>
		
		<method name="addCondition" args="currQueryNode">
			<![CDATA[
			// Get the first available view to set a default.
			var rootNode = qb_views.getFirstChild();
			var numberNodes = rootNode.childNodes.length;
			var viewNode = null;
			for (var i = 0; i < numberNodes; i++){
				viewNode = rootNode.childNodes[i];
				if (viewNode.hasChildNodes()){
					viewNode = viewNode.getFirstChild();
					break;
				} else {
					break;
				}
			}
			var viewName = viewNode.getAttr("field");
			
			// Get the first available comparison (id and value) to set a default.
			rootNode = qb_comps.getFirstChild();
			var compNodeArray = rootNode.getElementsByTagName("comp");
			var compNode = compNodeArray[0];
			var compNodeID = compNode.getAttr("value");
			var compNodeName = compNode.getAttr("name");
			
			// Figure out whether we have to simply append the new node or insert it.
			var doAppend = false;
			if (currQueryNode != null){
				//Debug.write("currQueryNode: " + currQueryNode.serialize());
				// Set the datapointer to the correct node.
				var nextQueryNode = currQueryNode.p.getNextSibling();
				if (nextQueryNode != null){
					//Debug.write("nextQueryNode: " + nextQueryNode.serialize());
					var newNode = this.getNewQueryNode();
					this.datapath.p.insertBefore(newNode, nextQueryNode);
				} else {
					doAppend = true;
				}
				
			} else {
				doAppend = true;
			}
			
			if (doAppend){
				//var newNode = this.datapath.addNodeFromPointer(this.getNewQueryNode());
				var newNode = this.datapath.addNode("node", "", 
								{	used:true,
									indent:0,
									type:"query",
									parent:"",
									number:0,
									field:viewName, 
									compID:compNodeID, 
									comparison:compNodeName, 
									value:"_____", 
									connection:"and", 
									value2:"_____"});
				//Debug.write("New Node is: " + newNode);
			}
			
			this.updateNumbering();
			Debug.write("parent: " + parent);
			parent.removeItem("50");
			
			// Add the new request row after two seconds.
			this.timerNewRequest = new LzDelegate(this, "addNewRequest");
			LzTimer.addTimer(this.timerNewRequest, 500);
			]]>
		</method>
		
		<method name="addBracket" args="currQueryNode">
			<![CDATA[
			Debug.write("Trying adding a bracket");
			Debug.write("parent: " + this.parent);
			var doAppend = false;
			var newNode = null;
			if (currQueryNode != null){
				Debug.write("currQueryNode: " + currQueryNode.serialize());
				var indent = currQueryNode.p.getAttr("indent");
				var parent = currQueryNode.p.getAttr("parent");
				// Set the datapointer to the correct node.
				var nextQueryNode = currQueryNode.p.getNextSibling();
				if (nextQueryNode != null){
					Debug.write("nextQueryNode: " + nextQueryNode.serialize());
					newNode = new LzDataElement("node", 
								{	used:true,
									indent:indent,
									type:"bracket",
									parent:parent,
									number:0,
									grouping:"all"});
					this.datapath.p.insertBefore(newNode, nextQueryNode);
				} else {
					doAppend = true;
				}
				
			} else {
				doAppend = true;
			}
			
			if (doAppend){
				newNode = this.datapath.addNode("node", "", 
								{	used:true,
									type:"bracket",
									indent:indent,
									parent:parent,
									number:0,
									grouping:"all"});
				Debug.write("New Node is: " + newNode);
			}
			
			this.updateNumbering();
			
			this.addCondition(newNode);
			]]>
		</method>
		
		<!-- Supposed to be a private method. Builds a new blank query node. -->
		<method name="getNewQueryNode">
			// Get the first available view to set a default.
			<![CDATA[
			var rootNode = qb_views.getFirstChild();
			var numberNodes = rootNode.childNodes.length;
			var viewNode = null;
			for (var i = 0; i < numberNodes; i++){
				viewNode = rootNode.childNodes[i];
				if (viewNode.hasChildNodes()){
					viewNode = viewNode.getFirstChild();
					break;
				} else {
					break;
				}
			}
			var viewName = viewNode.getAttr("field");
			
			// Get the first available comparison (id and value) to set a default.
			rootNode = qb_comps.getFirstChild();
			var compNodeArray = rootNode.getElementsByTagName("comp");
			var compNode = compNodeArray[0];
			var compNodeID = compNode.getAttr("value");
			var compNodeName = compNode.getAttr("name");
			
			// Now build the default blank node and return it.
			return new LzDataElement("node", 
								{	used:true,
									indent:0,
									type:"query",
									parent:"",
									number:0,
									field:viewName, 
									compID:compNodeID, 
									comparison:compNodeName, 
									value:"_____", 
									connection:"and", 
									value2:"_____"});
			]]>
		</method>
		
		<method name="addNewRequest">
			parent.addNewRequest();
		</method>
		
		<!-- Method updates the numbering of each condition. -->
		<method name="updateNumbering">
			<![CDATA[
				var rootNode = qb_query.getFirstChild();
				var numberNodes = rootNode.childNodes.length;
				var queryNode = null;
				var indent = 0;
				for (var i = 0; i < numberNodes; i++){
					queryNode = rootNode.childNodes[i];
					indent = queryNode.getAttr("indent");
					Debug.write("indent = " + indent);
					if (indent == 0){
						queryNode.setAttr("number", i+1);
					}
				}
			]]>
		</method>
		
		<!-- Displays the SQL 'translation'. This is based on the selected mode. 
					Currently we support the grouping mode.-->
		<method name="getSQL">
			<![CDATA[
			var sql = "";
			var rootNode = qb_query.getFirstChild();
			var queryNode = null;
			var row = 0;
			var used = false;
			var type = null;
			var number = 0;
			var field = null;
			var compID = 0;
			var comparison = null;
			var value = null;
			
			var condition = "??";
			switch (parent._qb_grouping_value){
				case 1:
					condition = "AND";
					break;
				case 2:
				case 3:
					condition = "OR";
					break;
				case 4:
					condition = "AND";
					break;
			}
		 	var numberNodes = rootNode.childNodes.length;
			for (var i = 0; i < numberNodes; i++){
				queryNode = rootNode.childNodes[i];
				used = queryNode.getAttr("used"); 
				if (!used){
					continue;
				} else {
					type = queryNode.getAttr("type");
					if (type == "bracket"){
						Debug.write("Dealing with a bracket. Skip at the moment");
						continue;
					}
					if (i > 0 && i < numberNodes){
						if (sql != ""){
							sql = sql + condition + " ";
						}
					}
				}
				
				row = queryNode.getAttr("row");
				number = queryNode.getAttr("number");
				field = queryNode.getAttr("field");
				compID = queryNode.getAttr("compID");
				comparison = queryNode.getAttr("comparison");
				value = queryNode.getAttr("value");
				if (value == '_____'){
					value = "";
				}
				// Deal with the pattern cases for the values.
				switch (compID){
					case 10: 	// starts with.
					case 11:  // does not start with.
						value = value + '%';
						break;
					case 12: 	// contains.
					case 13: 	// does not contain.
						value = '%' + value + '%';
				}
				// Deal with the IS NULL case.
				var thisRow = null;
				if (compID == 7){
					thisRow = "('" + field + "' " + this.getComparison(compID) + ")";
				} else {
					// Need to cater for BETWEEN and NOT BETWEEN.
					if (compID == 8 || compID == 9){
						var valArray = value.split(",");
						var tempVal = valArray.join("','");
						value = "('" + tempVal + "')";
						thisRow = "('" + field + "' " + this.getComparison(compID) + " " + value + ")";
					} else if (compID == 14 || compID == 15){
						value2 = queryNode.getAttr("value2");
						if (value2 == '_____'){
							value2 = "";
						}
						thisRow = "('" + field + "' " + this.getComparison(compID) + " '" + value + "' AND '" + value2 + "')";
					} else {
						thisRow = "('" + field + "' " + this.getComparison(compID) + " '" + value + "')";
					}
				}
				switch (compID){
					case 9:	 // is not in list.
					case 11: // does not start with.
					case 13: // does not contain.
						thisRow = '(NOT' + thisRow + ')';
						break;
				}
				sql = sql + thisRow + " ";
			}
			// Need to check whether we deal with the 'grouping' value of NONE.
			if (parent._qb_grouping_value == 3 || parent._qb_grouping_value == 4){
				sql = "NOT (" + sql + ")";
			}
			// Add the WHERE clause.
			sql = "WHERE " + sql;
			return sql;
			]]>
		</method>
		
		<method name="getComparison" args="compID">
			<![CDATA[
			var comp = "?";
			switch (compID){
				case 1:
					comp = "=";
					break;
				case 2:
					comp = "<>";
					break;
				case 3:
					comp = "<";
					break;
				case 4:
					comp = "<=";
					break;
				case 5:
					comp = ">";
					break;
				case 6:
					comp = ">=";
					break;
				case 7:
					comp = "IS NULL";
					break;
				case 8:   // is in list.
				case 9:   // is not in list.
					comp = "IN";
					break;
				case 10:	// starts with.
				case 11:  // does not start with.
				case 12:  // contains.
				case 13:  // does not contain.
					comp = "LIKE";
					break;
				case 14:	// between.
					comp = "BETWEEN";
					break;
				case 15:	// is not between.
					comp = "NOT BETWEEN";
					break;
			}
			return comp;
			]]>
		</method>
		
	</class>
</library>
